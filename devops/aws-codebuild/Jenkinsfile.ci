#!groovy

def evLibrary = library(identifier: 'evernym-aws-codebuild@aws-codebuild', retriever: modernSCM(
    github(credentialsId: 'evernym-github-machine-user', repoOwner: 'evernym', repository: 'jenkins-shared')
)).com.evernym.pipeline

logger = evLibrary.Logger.new(this)
notifier = evLibrary.Notifier.new(this)
logger.setGlobalLevel('TRACE')

pipelineWrapper({
    nodeWrapper {

        List osnames = [
            'xenial',
            //'centos7'
        ]
        def goals = ['test_dry', 'test']

        stage('Checkout from SCM') {
            checkout scm
        }

        def utils = evLibrary.Utils.new(this)
        // TODO Cargo.toml is necessary only for variable in makefile which is not used for that context, thus
        // shouldn't be taken into account when deciding to rebuild docker images
        def buildCtx = evLibrary.AwsCodeBuildHelper.BuildCtx.new('libsovtoken', ['devops', 'libsovtoken/Cargo.toml'])
        def awsCBHelper = evLibrary.AwsCodeBuildHelper.new(this, buildCtx)

        stage('Upload source to S3') {
            awsCBHelper.uploadSourceToS3()
        }

        Map builds = osnames.collectEntries { osname ->
            [(osname): {
                def buildImageTag
                def prTag = "ci-$osname"

                if (osname == 'xenial') {
                    stage('Download plugin debs') {
                        // TODO remove that code once repo.corp evernym.com
                        // become available from AWS CodeBuild

                        // TODO Aptly on repo.copr.evernym.com removes '+' signs
                        // from debian packages making versions in filenames
                        // not accurate (it concatenates them):
                        //  debian package version: <src_version>+<release_version>
                        //  debian package name:    <src_version><release_version>
                        def sovtoken_deb_version = "0.7.015.18"
                        def sovtokenfees_deb_version = "0.7.015.18"

                        sh """
                            cd ./devops/docker/ci/xenial/
                            wget --no-check-certificate https://repo.corp.evernym.com/deb/pool/main/s/sovtoken/sovtoken_${sovtoken_deb_version}_amd64.deb
                            wget --no-check-certificate https://repo.corp.evernym.com/deb/pool/main/s/sovtokenfees/sovtokenfees_${sovtoken_deb_version}_amd64.deb
                        """
                    }
                }

                stage("$osname: Resolve image tag") {
                    def _imgVersion = utils.shStdout("OSNAME=$osname make -C devops image_ci_version -s")
                    buildImageTag = "${_imgVersion}-${osname}-ci"
                    logger.info("CI docker image tag: $buildImageTag")
                }

                awsCBHelper.build() {
                    projectTag = prTag

                    // env and build spec
                    imageTag = buildImageTag
                    buildspec = 'devops/aws-codebuild/buildspec.ci.yml'
                    envv = [
                        [name: 'OSNAME', value: osname],
                        [name: 'MAKE_GOALS', value: "${goals.join(' ')}"],
                        [name: 'INDY_POOL_LOG_LEVEL', value: '10'],
                        [name: 'INDY_POOL_DIRS', value: '/tmp /var/lib/indy/sandbox /var/log/indy/sandbox'],
                    ]
                    computeType = 'medium'

                    // build spec for env image
                    envBuildSrc = ['devops', 'libsovtoken/Cargo.toml'] // TODO make more accurate
                    envBuildAddPaths = ['./devops/docker/ci/xenial/*.deb']
                    envBuildCmds = [
                        'export PROJECT_DIR=$PWD',
                        'make -C devops image_ci'
                    ]
                    envBuildLocalName = "evernym/libsovtoken:$buildImageTag"
                    envBuildEnvv = [
                        [name: 'OSNAME', value: osname],
                        [name: 'CI_DOCKER_TAG', value: buildImageTag],
                    ]

                    onArtifacts = {
                        this.stage("$osname: Archive artifacts") {
                            // make targets' logs
                            utils.archiveArtifacts("logs/*.log*") {
                                truncate = true
                                allowEmptyArchive = true
                                truncateFileSuffix = 'trunc.log'
                            }
                            // nodes' logs and validators info
                            utils.archiveArtifacts("logs/pool/*") {
                                truncate = false
                                allowEmptyArchive = true
                            }
                        }
                    }
                }
            }]
        }

        stage("Build and test") {
            builds.failFast = false
            utils.parallel builds
        }
    }
}, { err ->
    if (err) {
        logger.error("Pipeline failed with the error $err")
    }

    stage("Build result notification") {
        notifier.email()
    }
})
